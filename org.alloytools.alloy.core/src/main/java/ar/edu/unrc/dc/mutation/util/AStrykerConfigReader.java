package ar.edu.unrc.dc.mutation.util;

import java.io.*;
import java.util.Properties;

public class AStrykerConfigReader {

    public enum Config_key {
        VARIABILIZATION {
            @Override
            public String getKey() {
                return "astryker.repair.variabilization";
            }
        },
        VARIABILIZATION_SAME_TYPE {
            @Override
            public String getKey() {
                return "astryker.repair.variabilization.sametype";
            }
        },
        PARTIAL_REPAIR {
            @Override
            public String getKey() {
                return "astryker.repair.partialrepair";
            }
        },
        USE_PO_TO_VALIDATE {
            @Override
            public String getKey() {
                return "astryker.repair.validatewithpo";
            }
        },
        TIMEOUT {
            @Override
            public String getKey() {
                return "astryker.repair.timeout";
            }
        },
        MAX_DEPTH {
            @Override
            public String getKey() {
                return "astryker.repair.maxdepth";
            }
        }
        ;
        public abstract String getKey();

    }

    /**
     * The path to a default .properties file
     */
    private static final String DEFAULT_PROPERTIES = "astryker.properties";

    /**
     * The {@code StrykerConfig} instance that will be returned by {@link AStrykerConfigReader#getInstance()}
     */
    private static AStrykerConfigReader instance = null;

    /**
     * @return a previously built instance or construct a new instance using {@code StrykerConfig#DEFAULT_PROPERTIES}
     */
    public static AStrykerConfigReader getInstance() {
        if (instance == null) {
            try {
                instance = new AStrykerConfigReader();
            } catch (IOException e) {
                throw new IllegalStateException("Exception when trying to load properties");
            }
        }
        return instance;
    }

    private AStrykerConfigReader() throws IOException {
        prop = new Properties();
        loadPropertiesFromFile();
    }

    private void loadPropertiesFromFile() throws IOException {
        String cwd = System.getProperty("user.dir");
        String configFile = cwd + File.separator + DEFAULT_PROPERTIES;
        File propFile = createConfigFileIfMissing(configFile);
        InputStream inputStream = new FileInputStream(propFile);
        prop.load(inputStream);
    }

    private Properties prop;

    private File createConfigFileIfMissing(String configFile) throws IOException {
        File propFile = new File(configFile);
        if (!propFile.exists())
            if (!propFile.createNewFile())
                throw new IllegalStateException("Couldn't create new file " + configFile);
        return propFile;
    }

    public void loadConfig() throws IOException {
        loadPropertiesFromFile();
    }

    public void saveConfig() throws IOException {
        if (prop == null)
            prop = new Properties();
        String cwd = System.getProperty("user.dir");
        String configFile = cwd + File.separator + DEFAULT_PROPERTIES;
        File propFile = createConfigFileIfMissing(configFile);
        OutputStream outputStream = new FileOutputStream(propFile);
        prop.store(outputStream, "ASTRYKER AUTOGENERATED PROPERTIES - DO NOT MODIFY");
    }

    public boolean getBooleanArgument(Config_key key) {
        if (!isBooleanKey(key))
            throw new IllegalStateException("Config key is not boolean " + key.toString());
        if (!isDefined(key))
            return false;
        String propValue = prop.getProperty(key.getKey());
        if (propValue == null)
            return false;
        return Boolean.parseBoolean(propValue);
    }

    public int getIntArgument(Config_key key) {
        if (!isIntKey(key))
            throw new IllegalStateException("Config key is not int " + key.toString());
        if (!isDefined(key))
            return 0;
        String propValue = prop.getProperty(key.getKey());
        if (propValue == null)
            return 0;
        return Integer.parseInt(propValue);
    }

    public void setIntArgument(Config_key key, int value) {
        if (!isIntKey(key))
            throw new IllegalStateException("Config key is not int " + key.toString());
        prop.setProperty(key.getKey(), Integer.toString(value));
    }

    public void setBooleanArgument(Config_key key, boolean value) {
        if (!isBooleanKey(key))
            throw new IllegalStateException("Config key is not boolean " + key.toString());
        prop.setProperty(key.getKey(), Boolean.toString(value));
    }

    private boolean isDefined(Config_key key) {
        return prop.containsKey(key.getKey());
    }


    private boolean isBooleanKey(Config_key key) {
        switch (key) {
            case VARIABILIZATION:
            case VARIABILIZATION_SAME_TYPE:
            case USE_PO_TO_VALIDATE:
            case PARTIAL_REPAIR: return true;
            default : return false;
        }
    }

    private boolean isIntKey(Config_key key) {
        switch (key) {
            case TIMEOUT    :
            case MAX_DEPTH  :  return true;
            default : return false;
        }
    }


}
